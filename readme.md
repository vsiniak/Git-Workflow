# Git workflow

## Ведение

В этом документе я хочу описать, как хранить свой код команде разработчиков из 2-3 человек максимально эффективно и удобно. Вообще подход актуален и для команд других размеров, и для хранения не только кода, но в этих случаях он будет иметь свои особенности.

Речь пойдёт о git-репозитории, но всё нижеизложенное актуально и для других аналогичных систем контроля версий (распределённых, поддерживающих ветвление и т.п.).

## Оглавление

* [Что я хочу от репозитория](#Что-я-хочу-от-репозитория)
* [Как это сделать](#Как-это-сделать)
* [Одна голова хорошо, а две лучше](#Одна-голова-хорошо-а-две-лучше)
* [Code review](#code-review)
* [Собираем вместе](#Собираем-вместе)
* [Реальный мир](#Реальный-мир)

## Что я хочу от репозитория

**Я разработчик**

* Хранить мой код некой фичи, которую я пишу.
* Получить общий код всей команды, чтобы начать писать новую фичу. Желательно, чтобы этот код ещё и собирался. И запускался.

**Я PM/QA**

* Получить код (и собрать билд), чтобы посмотреть статус/прогресс и потестировать новые фичи.

**Я пользователь**

Кого я понимаю под *пользователем* кода. Это тот человек (группа людей), к которому код (в виде билда) попадёт, выйдя за пределы моей компании. Для собственных проектов компании -- это пользователи приложения. Для outsource-проектов -- это в первую очередь клиент компании (а затем уже и пользователи приложения).

* Получить работоспособный протестированный код с новыми фичами. Собрать билд и запаблишить его.

## Как это сделать

Создать в репозитории ветки для всех ролей.

<img src="/general_example/general_example.png">

**master**

Ветка, в которой лежит код, который в любой момент можно отправить *пользователю* (см. выше). Это важно: код должен быть настолько хорош, чтобы PM мог нажать кнопку build на CI-сервере и отправить билд клиенту.

В *master* код попадает из *dev* после успешного тестирования QA.

**dev**

Когда разработчик дописывает фичу в своей ветке, код этой ветки попадает в dev. Этот код будет браться разработчиками за основу при допиливании новых фич, а также этот код будет отправляться на тестирование QA. Поэтому при мерже веток в dev нужно убедиться, что код собирается, запускается и работает основной workflow.

**feature**

Непосредственно фичи (и багфикс) пилятся в отдельных ветках, каждой фиче своя ветка.

После мержа в *dev* ветка фичи удаляется.

## Одна голова хорошо, а две лучше

Как только были выполнены все пожелания выше, появились новые.

**Я разработчик-перфекционист**

* Хочу лучше понимать, как работает проект (как работают фичи, которые пишут другие участники команды), чтобы эффективнее интегрировать новые фичи.
* Хочу больше знать о технологиях/паттернах/подходах/..., которые используют другие участники команды (шаринг опыта).
* Хочу быть уверенным, что другие участники команды пишут корректный код.
* Хочу быть уверенным, что установленные на проекте правила (про ветки выше, code style) соблюдаются.

## Code review

Чтобы всё было так, как описано выше, нужно, чтобы код, перед тем как попасть в общую ветку *dev*, изучался и проверялся командой -- проходил code review.

Как это сделать? Использовать *pull request* от Bitbucket/Github/... или аналогичную фичу от других хостингов (*merge request* от Assembla).

Когда разработчик завершает фичу, он делает pull request из *feature* в *dev*, который может смержить только другой разработчик после code review изменений.

### Джентльменские правила pull request

Чтобы pull request'ы не зависали надолго в ожидании, нужно соблюдать следующие правила.

* Pull request -- это таска с наивысшим приоритетом.

После завершения работы над фичей, сперва нужно проверить открытые pull request'ы, и только затем приступать к реализации новой фичи.

* Pull request'ы мержатся в том порядке, в котором они были созданы.

Так как ветка *dev* развивается параллельно с ветками *feature*, при мерже могут возникнуть конфликты. При этом в ветку *dev* код попадает только через pull request'ы. Правило нужно, чтобы свести эту вероятность к минимуму для тех, кто создал pull request раньше.

Второе правило сильнее первого: если разработчик завершил таску и есть открытые pull request'ы, созданные после его всё ещё открытого pull request'а, разработчик можеть отложить их ревью до тех пор, пока не закроется его pull request (чтобы не получилось, что мерж привёл к конфликтам в его pull request'е).

Таким образом, разработчики заинтересованы в том, чтобы ревьюить pull request'ы как можно скорее.

* Pull request ревьюит первый освободившийся разработчик.

Иногда это правило может заменяться правилом "pull request ревьюит тимлид".

* Один ревьюер доводит ревью до конца.

Когда разработчик начинает ревью, он ассайнит pull request на себя. Если во время ревью возникают замечания, требующие исправления, после обновления pull request ревьюит тот же ревьюер.

В противном случае разные ревьюеры могу быть разного мнения об изменениях (архитектура решения, реализация функции) и может начаться перетягивание каната.

### Как ревьюить pull-request

При ревью важно проделать ту работу, которую не может сделать статический анализатор кода: нужно понять архитектуру реализации фичи, оценить её гибкость/универсальность/оптимальность, проанализировать её взаимодействие с другими модулями и фичами, проверить её соответствие ТЗ.

Затем нужно проревьюить реализацию этой архитектуры -- код классов и методов. При этом происходит как проверка кода, так и двунаправленное перенятие опыта: ревьюер может как учиться новым фишкам из кода, так и подсказать автору лучшее решение.

## Собираем вместе

Итак, необходимо реализовать фичу *login*. Для начала нужно слить актуальный код.

```
git pull
```

Новая фича будет пилиться в соответствующей ветке *login*.

```
git checkout dev
git checkout -b login
```

Реализовав и закоммитив новую фичу, нужно убедиться, что при мерже в *dev* не будет конфликтов, и после мержа новый функционал будет работать как положено. Для этого ветка фичи мержится с актуальной *dev* и фича тестируется.

```
git pull
git merge dev
```

После необходимых правок ветка пушится и создаётся pull request. Можно переключаться на новые задачи.

```
git push -u origin login
```

Если во время ревью возникают замечания, требующие исправления, нужно вернуться к ним, закончив текущую задачу. Pull request правится в той же ветке, из которой он создан.

После исправления замечаний нужно снова проверить ветку фичи на корректность мержа с *dev*, после чего можно запушить изменения, обновив тем самым pull request.

```
git pull
git merge dev
git push
```

После накопления обновлений в *dev*, достаточных для релиза/билда/демо, QA проводит тестирование билда, собранного из *dev*. После успешного тестирования *master* мержится с *dev*. Этот мерж удобно делать через pull request (который не проходит ревью -- просто мержится): так удобнее смотреть историю изменений.

## Реальный мир

### Огромные pull request'ы

Максимально эффективно можно проверьюить pull request если:

* pull request содержит разумное количество изменений (не очень много кода);
* pull request содержит одну фичу.

При этом, pull request в *dev* должен содержать законченную фичу (не только UI или только логику).

Выполнить эти три условия одновременно едва ли возможно.

Предположим, необходимо реализовать фичу login. Она состоит из трёх основных задач:

1. взаимодействие с web api бэкенда (дёрнуть запросы для логина и логаута);
2. UI (для логина и для логаута);
3. логика (отображать соответствующий UI для залогиненного/разлогиненного пользователя, включать заголовок авторизации в запросы, хранить токен авторизации).

Логично пилить каждую задачу в своей ветке. Это удовлетворит два условия выше. При этом ветки будут порождаться не из *dev*, а из ветки фичи *login*. После реализации каждой задачи, будет создаваться pull request из ветки задачи в *login*.

После реализации всех подзадач, нужно создать pull request из *login* в *dev*. Это удовлетворит третье условие.

<img src="/subfeature_example/subfeature_example.png">

Pull request из *login* в *dev* будет содержать много изменений, поэтому его ревью будет неэффективным -- его даже можно опустить. Несмотря на то, что каждая из подзадач была проревьюена ранее, всю фичу, собранную вместе, тоже следует проверить. Для этого кроме ревью нужно собрать билд из ветки *login* и протестировать. Если для этих целей нельзя использовать QA (его время регламентировано, долго ждать очереди), простейшее тестирование может провести ревьюер.

Практика тестирования больших или сложных pull request'ов сильно повышает качество кода, так как баги находятся непосредственно в той ветке, в которой они были созданы, и непосредственно после того, как были созданы. Поэтому так следует делать не только для "составных" фич, как *login* выше, а для любых других, для которых такое решение выглядит разумно.

### Зависимые фичи

Нередко фичи бывают связанными: для реализации новой фичи нужна только что законченная. При этом она ещё не прошла ревью и не влита в *dev*, а ждать ревью -- не вариант. В этом случае зависимую фичу нужно реализовывать в ветке, порождённой из фичи-зависимости: эта ветка содержит актуальные изменения из *dev* и саму фичу-зависимость.

Предположим, только что была реализована и отправлена на ревью фича *login*, и необходимо реализовать *profile*. При этом для реализации профиля нужна авторизация.

```
git checkout login
git checkout -b profile
```

Если к моменту завершения реализации фичи *login* смержен в *dev*, создаётся pull request в *dev*, как обычно.

Если *login* ждёт ревью, то pull request в *dev* будет содержать не только фичу *profile*, но и *login*. Поэтому следует создать pull request в *login* с пометкой, что это зависимая фича и после мержа *login* pull request следует перенаправить в *dev*. При этом pull request не следует мержить до тех пор, пока не будет смержен *login* -- иначе после мержа ветка *login* будет также содержать и фичу *profile*.

### Багфикс -- фича?

Если баг в какой-либо фиче найден во время ревью или тестирования pull request'а соответствующей фичи, то это не баг, а замечание к pull request'у. Которое, в свою очередь, исправляется по общим правилам (обновление pull request'а из той же ветки).

Баги, не имеющие отношения к pull request'ам (то есть найденные во время тестирования билда из *dev*, найденные при тестировании *feature* в других фичах, найденные после мержа pull request'а), фиксятся в виде фичи *багфикс*. Которая, в свою очередь, реализовывается по общим правилам (в соответствующей ветке с ревью pull request'а).
